-- Genetic Algorithm in Lea
-- Evolves a population of strings to match a target phrase
-- Demonstrates: match, destructuring, spread pipe, codeblocks, type annotations

-- Configuration
let TARGET = "LEA"
let POPULATION_SIZE = 40
let MUTATION_RATE = 0.05
let GENERATIONS = 150

-- Character set for generating random strings
let CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZ "

<> -- Helper Functions

-- Generate a random character from our charset
let randomChar = (_) -> CHARS /> chars /> randomChoice :: Int :> String

-- Generate a random individual (string of target length)
let randomIndividual = (_) -> :: Int :> String
  TARGET /> length /> iterations />>> randomChar /> join("")

-- Calculate fitness: count matching characters (higher is better)
-- Uses zip and spread pipe with index access
let fitness = (individual) -> :: String :> Int
  let individualChars = chars(individual)
  let targetChars = chars(TARGET)
  zip([individualChars, targetChars])
    /> filter((pair) -> pair[0] == pair[1])
    /> length

</>

<> -- Selection

-- Pick the fitter of two individuals using match
let fitter = (a, b) -> :: (String, String) :> String
  match fitness(a) > fitness(b)
    | true -> a
    | b

-- Tournament selection: pick best from k random candidates
let tournamentSelect = (population, k) -> :: (List, Int) :> String
  let pickRandom = (_) -> randomChoice(population)
  let candidates = iterations(k) />>> pickRandom
  candidates /> reduce(head(candidates), fitter)

-- Select parent using tournament selection
let selectParent = (population) -> tournamentSelect(population, 3) :: List :> String

</>

<> -- Genetic Operators

-- Single-point crossover: combine two parents
let crossover = (parent1, parent2) -> :: (String, String) :> String
  let point = randomInt(1, length(TARGET))
  let p1Chars = chars(parent1)
  let p2Chars = chars(parent2)
  [...slice(p1Chars, 0, point), ...slice(p2Chars, point)] /> join("")

-- Maybe mutate a character based on mutation rate
let maybeMutate = (c) -> random() < MUTATION_RATE ? randomChar(0) : c :: String :> String

-- Mutate an individual: randomly change characters
let mutate = (individual) -> :: String :> String
  chars(individual) />>> maybeMutate /> join("")

-- Create offspring pipeline
let breedPipeline = /> mutate

-- Create single offspring from two parents
let breed = (parent1, parent2) -> :: (String, String) :> String
  crossover(parent1, parent2) /> breedPipeline

</>

<> -- Population Management

-- Create initial random population
let createPopulation = () ->
  iterations(POPULATION_SIZE) />>> randomIndividual

-- Get the best individual in population
let bestIndividual = (population) -> :: List :> String
  population /> reduce(head(population), fitter)

-- Create one child for the next generation
let createChild = (population) -> :: List :> String
  let p1 = selectParent(population)
  let p2 = selectParent(population)
  breed(p1, p2)

-- Create next generation with elitism (best individual preserved)
let evolveGeneration = (population) -> :: List :> List
  let elite = bestIndividual(population)
  let breedOne = (_) -> createChild(population)
  let children = iterations(POPULATION_SIZE - 1) />>> breedOne
  [...children, elite]

</>

<> -- Main Evolution Loop

-- Log progress every 10 generations
let logProgress = (gen, best, bestFit) ->
  gen % 10 == 0
    ? `Gen {gen}: "{best}" (fitness: {bestFit}/{length(TARGET)})` /> print
    : 0

-- Handle found target state
let handleFoundTarget = (state, generation, best) ->
  `Found target "{TARGET}" in generation {generation}!` /> print
  { ...state, done: true, best: best }

-- Handle max generations state
let handleMaxedOut = (state, best) ->
  `Max generations. Best: "{best}"` /> print
  { ...state, done: true, best: best }

-- Handle continue evolution state
let handleContinue = (state, population, generation, best) ->
  {
    ...state,
    population: evolveGeneration(population),
    generation: generation + 1,
    best: best,
  }

-- Determine next state
-- Uses record destructuring and spread operator
let nextState = (state, best, bestFit) ->
  let { population, generation } = state
  let foundTarget = best == TARGET
  let maxedOut = generation >= GENERATIONS
  foundTarget ? handleFoundTarget(state, generation, best) : maxedOut ? handleMaxedOut(state, best) : handleContinue(state, population, generation, best)

-- Single evolution step
let step = (state) ->
  let { population, generation } = state
  let best = bestIndividual(population)
  let bestFit = fitness(best)
  logProgress(generation, best, bestFit)
  nextState(state, best, bestFit)

-- Run evolution loop (tail recursive)
let runLoop = (state) -> match state.done
  | true -> state.best
  | runLoop(step(state))

-- Main entry point
let runGA = () ->
  "=== Genetic Algorithm ===" /> print
  `Target: "{TARGET}"` /> print
  `Population: {POPULATION_SIZE}, Mutation Rate: {MUTATION_RATE}` /> print
  "" /> print

  let initialState = {
    population: createPopulation(),
    generation: 0,
    best: "",
    done: false,
  }

  let result = runLoop(step(initialState))
  "" /> print
  `Final result: "{result}"` /> print
  result

</>

-- Run the algorithm
runGA()
