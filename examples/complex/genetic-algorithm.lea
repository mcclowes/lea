-- Genetic Algorithm in Lea
-- Evolves a population of strings to match a target phrase
-- Demonstrates: mutation, crossover, selection, fitness functions

-- Configuration (tuned for tree-walk interpreter performance)
let TARGET = "LEA"
let POPULATION_SIZE = 40
let MUTATION_RATE = 0.05
let GENERATIONS = 150

-- Character set for generating random strings
let CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZ "

<> -- Helper Functions

-- Generate a random character from our charset
-- Uses _ to ignore input, enabling use with spread pipe
let randomChar = (_) -> randomChoice(chars(CHARS)) :: Int :> String

-- Generate a random individual (string of target length)
-- Uses iterations with spread pipe for cleaner generation
let randomIndividual = (_) -> :: Int :> String
  iterations(length(TARGET)) />> randomChar /> join("")

-- Calculate fitness: count matching characters (higher is better)
-- Uses zip and filter pipeline pattern
let fitness = (individual) -> :: String :> Int
  zip([chars(individual), chars(TARGET)])
    /> filter((pair) -> at(pair, 0) == at(pair, 1))
    /> length

</>

<> -- Selection

-- Pick the fitter of two individuals
let fitter = (a, b) -> fitness(a) > fitness(b) ? a : b :: (String, String) :> String

-- Tournament selection: pick best from k random candidates
-- Uses iterations with spread pipe for candidate generation
let tournamentSelect = (population, k) -> :: (List, Int) :> String
  let pickRandom = (_) -> randomChoice(population)
  let candidates = iterations(k) />> pickRandom
  candidates /> reduce(head(candidates), fitter)

-- Select parent using tournament selection
let selectParent = (population) -> tournamentSelect(population, 3) :: List :> String

</>

<> -- Genetic Operators

-- Single-point crossover: combine two parents
-- Slices at random point and combines halves
let crossover = (parent1, parent2) -> :: (String, String) :> String
  let point = randomInt(1, length(TARGET))
  let p1Chars = chars(parent1)
  let p2Chars = chars(parent2)
  concat(slice(p1Chars, 0, point), slice(p2Chars, point)) /> join("")

-- Maybe mutate a character based on mutation rate
let maybeMutate = (c) -> random() < MUTATION_RATE ? randomChar(0) : c :: String :> String

-- Mutate an individual: randomly change characters
-- Uses pipeline pattern for character transformation
let mutate = (individual) -> :: String :> String
  chars(individual) />> maybeMutate /> join("")

-- Create single offspring from two parents
-- Combines crossover and mutation in a pipeline
let breed = (parent1, parent2) -> :: (String, String) :> String
  crossover(parent1, parent2) /> mutate

</>

<> -- Population Management

-- Create initial random population
-- Uses iterations with spread pipe for clean generation
let createPopulation = () ->
  iterations(POPULATION_SIZE) />> randomIndividual

-- Get the best individual in population
let bestIndividual = (population) -> :: List :> String
  population /> reduce(head(population), fitter)

-- Create one child for the next generation
let createChild = (population) -> :: List :> String
  let p1 = selectParent(population)
  let p2 = selectParent(population)
  breed(p1, p2)

-- Create next generation with elitism (best individual preserved)
-- Uses iterations with spread pipe for child generation
let evolveGeneration = (population) -> :: List :> List
  let elite = bestIndividual(population)
  let breedOne = (_) -> createChild(population)
  let children = iterations(POPULATION_SIZE - 1) />> breedOne
  push(children, elite)

</>

<> -- Main Evolution Loop

-- Log progress every 10 generations
let logProgress = (gen, best, bestFit) ->
  gen % 10 == 0 ? `Gen {gen}: "{best}" (fitness: {bestFit}/{length(TARGET)})` /> print : 0

-- Single evolution step (returns {population, best, done, generation})
let step = (state) ->
  let pop = state.population
  let gen = state.generation
  let best = bestIndividual(pop)
  let bestFit = fitness(best)
  let done = best == TARGET
  let maxed = gen >= GENERATIONS
  logProgress(gen, best, bestFit)
  done ? `Found target "{TARGET}" in generation {gen}!` /> print : 0
  maxed ? `Max generations. Best: "{best}"` /> print : 0
  {
    population: done ? pop : (maxed ? pop : evolveGeneration(pop)),
    generation: gen + 1,
    best: best,
    done: done ? true : maxed,
  }

-- Run evolution loop (tail recursive)
let runLoop = (state) ->
  state.done ? state.best : runLoop(step(state))

-- Main entry point
let runGA = () ->
  "=== Genetic Algorithm ===" /> print
  `Target: "{TARGET}"` /> print
  `Population: {POPULATION_SIZE}, Mutation Rate: {MUTATION_RATE}` /> print
  "" /> print
  let initialState = {
    population: createPopulation(),
    generation: 0,
    best: "",
    done: false,
  }
  let result = runLoop(step(initialState))
  "" /> print
  `Final result: "{result}"` /> print
  result

</>

-- Run the algorithm
runGA()
