/**
 * Documentation for Lea built-in functions
 *
 * This module provides documentation for all built-in functions
 * to support hover information and autocomplete.
 */

import { BuiltinDoc } from "./types";

/**
 * Documentation for all Lea built-in functions
 */
export const BUILTIN_DOCS: Record<string, BuiltinDoc> = {
  // Output
  print: {
    name: "print",
    signature: "print(value, ...values) -> value",
    description: "Prints values to console and returns the first argument for chaining.",
    params: [
      { name: "value", type: "any", description: "The value to print and return" },
      { name: "...values", type: "any", description: "Additional values to print" },
    ],
    returns: { type: "any", description: "Returns the first argument" },
    examples: [
      '42 /> print  -- prints 42 and returns 42',
      '"Hello" /> print /> length  -- prints "Hello" then returns 5',
    ],
  },

  // Math functions
  sqrt: {
    name: "sqrt",
    signature: "sqrt(number) -> Number",
    description: "Returns the square root of a number.",
    params: [{ name: "number", type: "Number", description: "The number to get the square root of" }],
    returns: { type: "Number", description: "The square root" },
    examples: ["16 /> sqrt  -- 4", "2 /> sqrt   -- 1.414..."],
  },
  abs: {
    name: "abs",
    signature: "abs(number) -> Number",
    description: "Returns the absolute value of a number.",
    params: [{ name: "number", type: "Number", description: "The input number" }],
    returns: { type: "Number", description: "The absolute value" },
    examples: ["-5 /> abs  -- 5", "5 /> abs   -- 5"],
  },
  floor: {
    name: "floor",
    signature: "floor(number) -> Int",
    description: "Rounds a number down to the nearest integer.",
    params: [{ name: "number", type: "Number", description: "The number to floor" }],
    returns: { type: "Int", description: "The floored integer" },
    examples: ["3.7 /> floor  -- 3", "-3.7 /> floor -- -4"],
  },
  ceil: {
    name: "ceil",
    signature: "ceil(number) -> Int",
    description: "Rounds a number up to the nearest integer.",
    params: [{ name: "number", type: "Number", description: "The number to ceil" }],
    returns: { type: "Int", description: "The ceiled integer" },
    examples: ["3.2 /> ceil  -- 4", "-3.2 /> ceil -- -3"],
  },
  round: {
    name: "round",
    signature: "round(number) -> Int",
    description: "Rounds a number to the nearest integer.",
    params: [{ name: "number", type: "Number", description: "The number to round" }],
    returns: { type: "Int", description: "The rounded integer" },
    examples: ["3.5 /> round  -- 4", "3.4 /> round  -- 3"],
  },
  min: {
    name: "min",
    signature: "min(a, b, ...rest) -> Number",
    description: "Returns the minimum of the given numbers.",
    params: [
      { name: "a", type: "Number", description: "First number" },
      { name: "b", type: "Number", description: "Second number" },
      { name: "...rest", type: "Number", description: "Additional numbers" },
    ],
    returns: { type: "Number", description: "The minimum value" },
    examples: ["min(3, 1, 4)  -- 1", "5 /> min(3)   -- 3"],
  },
  max: {
    name: "max",
    signature: "max(a, b, ...rest) -> Number",
    description: "Returns the maximum of the given numbers.",
    params: [
      { name: "a", type: "Number", description: "First number" },
      { name: "b", type: "Number", description: "Second number" },
      { name: "...rest", type: "Number", description: "Additional numbers" },
    ],
    returns: { type: "Number", description: "The maximum value" },
    examples: ["max(3, 1, 4)  -- 4", "5 /> max(3)   -- 5"],
  },

  // Advanced math functions
  pow: {
    name: "pow",
    signature: "pow(base, exponent) -> Number",
    description: "Returns base raised to the power of exponent.",
    params: [
      { name: "base", type: "Number", description: "The base" },
      { name: "exponent", type: "Number", description: "The exponent" },
    ],
    returns: { type: "Number", description: "base^exponent" },
    examples: ["pow(2, 10)  -- 1024", "pow(3, 2)   -- 9"],
  },
  log: {
    name: "log",
    signature: "log(x) -> Number | log(x, base) -> Number",
    description: "Returns the logarithm. Natural log with one arg, or log with specified base.",
    params: [
      { name: "x", type: "Number", description: "The number" },
      { name: "base", type: "Number", description: "The base (default: e)" },
    ],
    returns: { type: "Number", description: "The logarithm" },
    examples: ["log(E())     -- 1", "log(8, 2)   -- 3"],
  },
  log10: {
    name: "log10",
    signature: "log10(x) -> Number",
    description: "Returns the base-10 logarithm.",
    params: [{ name: "x", type: "Number", description: "The number" }],
    returns: { type: "Number", description: "The base-10 logarithm" },
    examples: ["log10(100)  -- 2", "log10(1000) -- 3"],
  },
  log2: {
    name: "log2",
    signature: "log2(x) -> Number",
    description: "Returns the base-2 logarithm.",
    params: [{ name: "x", type: "Number", description: "The number" }],
    returns: { type: "Number", description: "The base-2 logarithm" },
    examples: ["log2(8)   -- 3", "log2(256) -- 8"],
  },
  exp: {
    name: "exp",
    signature: "exp(x) -> Number",
    description: "Returns e raised to the power of x.",
    params: [{ name: "x", type: "Number", description: "The exponent" }],
    returns: { type: "Number", description: "e^x" },
    examples: ["exp(0)  -- 1", "exp(1)  -- 2.718..."],
  },
  sin: {
    name: "sin",
    signature: "sin(x) -> Number",
    description: "Returns the sine of x (in radians).",
    params: [{ name: "x", type: "Number", description: "Angle in radians" }],
    returns: { type: "Number", description: "The sine" },
    examples: ["sin(0)         -- 0", "sin(PI() / 2)  -- 1"],
  },
  cos: {
    name: "cos",
    signature: "cos(x) -> Number",
    description: "Returns the cosine of x (in radians).",
    params: [{ name: "x", type: "Number", description: "Angle in radians" }],
    returns: { type: "Number", description: "The cosine" },
    examples: ["cos(0)    -- 1", "cos(PI()) -- -1"],
  },
  tan: {
    name: "tan",
    signature: "tan(x) -> Number",
    description: "Returns the tangent of x (in radians).",
    params: [{ name: "x", type: "Number", description: "Angle in radians" }],
    returns: { type: "Number", description: "The tangent" },
    examples: ["tan(0)         -- 0", "tan(PI() / 4)  -- 1"],
  },
  sign: {
    name: "sign",
    signature: "sign(x) -> Int",
    description: "Returns the sign of x: -1, 0, or 1.",
    params: [{ name: "x", type: "Number", description: "The number" }],
    returns: { type: "Int", description: "-1, 0, or 1" },
    examples: ["sign(-5)  -- -1", "sign(0)   -- 0", "sign(5)   -- 1"],
  },
  trunc: {
    name: "trunc",
    signature: "trunc(x) -> Int",
    description: "Truncates the decimal part of a number.",
    params: [{ name: "x", type: "Number", description: "The number" }],
    returns: { type: "Int", description: "The integer part" },
    examples: ["trunc(3.9)   -- 3", "trunc(-3.9)  -- -3"],
  },
  clamp: {
    name: "clamp",
    signature: "clamp(x, min, max) -> Number",
    description: "Clamps x to the range [min, max].",
    params: [
      { name: "x", type: "Number", description: "The value to clamp" },
      { name: "min", type: "Number", description: "Minimum value" },
      { name: "max", type: "Number", description: "Maximum value" },
    ],
    returns: { type: "Number", description: "The clamped value" },
    examples: ["clamp(15, 0, 10)  -- 10", "clamp(-5, 0, 10)  -- 0", "clamp(5, 0, 10)   -- 5"],
  },
  lerp: {
    name: "lerp",
    signature: "lerp(a, b, t) -> Number",
    description: "Linear interpolation between a and b by factor t.",
    params: [
      { name: "a", type: "Number", description: "Start value" },
      { name: "b", type: "Number", description: "End value" },
      { name: "t", type: "Number", description: "Interpolation factor (0-1)" },
    ],
    returns: { type: "Number", description: "Interpolated value" },
    examples: ["lerp(0, 10, 0.5)   -- 5", "lerp(0, 100, 0.25) -- 25"],
  },

  // Math constants
  PI: {
    name: "PI",
    signature: "PI() -> Number",
    description: "Returns the mathematical constant pi (3.14159...).",
    params: [],
    returns: { type: "Number", description: "Pi" },
    examples: ["PI()  -- 3.14159..."],
  },
  E: {
    name: "E",
    signature: "E() -> Number",
    description: "Returns Euler's number e (2.71828...).",
    params: [],
    returns: { type: "Number", description: "e" },
    examples: ["E()  -- 2.71828..."],
  },
  TAU: {
    name: "TAU",
    signature: "TAU() -> Number",
    description: "Returns tau (2*pi, 6.28318...).",
    params: [],
    returns: { type: "Number", description: "Tau" },
    examples: ["TAU()  -- 6.28318..."],
  },
  INFINITY: {
    name: "INFINITY",
    signature: "INFINITY() -> Number",
    description: "Returns positive infinity.",
    params: [],
    returns: { type: "Number", description: "Infinity" },
    examples: ["INFINITY()  -- Infinity"],
  },

  // Random functions
  random: {
    name: "random",
    signature: "random() -> Number",
    description: "Returns a random float in [0, 1).",
    params: [],
    returns: { type: "Number", description: "A random number between 0 (inclusive) and 1 (exclusive)" },
    examples: ["random()  -- 0.7342..."],
  },
  randomInt: {
    name: "randomInt",
    signature: "randomInt(max) -> Int | randomInt(min, max) -> Int",
    description: "Returns a random integer. With one arg: [0, max). With two args: [min, max).",
    params: [
      { name: "min", type: "Int", description: "Minimum value (inclusive), defaults to 0" },
      { name: "max", type: "Int", description: "Maximum value (exclusive)" },
    ],
    returns: { type: "Int", description: "A random integer" },
    examples: ["randomInt(10)     -- 0-9", "randomInt(5, 10)  -- 5-9"],
  },
  randomFloat: {
    name: "randomFloat",
    signature: "randomFloat(max) -> Number | randomFloat(min, max) -> Number",
    description: "Returns a random float. With one arg: [0, max). With two args: [min, max).",
    params: [
      { name: "min", type: "Number", description: "Minimum value (inclusive), defaults to 0" },
      { name: "max", type: "Number", description: "Maximum value (exclusive)" },
    ],
    returns: { type: "Number", description: "A random float" },
    examples: ["randomFloat(10.0)       -- 0.0-9.999...", "randomFloat(5.0, 10.0)  -- 5.0-9.999..."],
  },
  randomChoice: {
    name: "randomChoice",
    signature: "randomChoice(list) -> any",
    description: "Returns a random element from a list.",
    params: [{ name: "list", type: "[any]", description: "The list to choose from" }],
    returns: { type: "any", description: "A random element from the list" },
    examples: ['randomChoice([1, 2, 3])         -- 1, 2, or 3', 'randomChoice(["a", "b", "c"])  -- "a", "b", or "c"'],
  },
  shuffle: {
    name: "shuffle",
    signature: "shuffle(list) -> [any]",
    description: "Returns a shuffled copy of the list (Fisher-Yates algorithm).",
    params: [{ name: "list", type: "[any]", description: "The list to shuffle" }],
    returns: { type: "[any]", description: "A new shuffled list" },
    examples: ["[1, 2, 3, 4, 5] /> shuffle  -- [3, 1, 5, 2, 4] (random order)"],
  },

  // List functions
  length: {
    name: "length",
    signature: "length(list | string) -> Int",
    description: "Returns the length of a list or string.",
    params: [{ name: "list | string", type: "[any] | String", description: "The list or string to measure" }],
    returns: { type: "Int", description: "The length" },
    examples: ["[1, 2, 3] /> length   -- 3", '"hello" /> length    -- 5'],
  },
  head: {
    name: "head",
    signature: "head(list) -> any",
    description: "Returns the first element of a list. Throws if list is empty.",
    params: [{ name: "list", type: "[any]", description: "The list" }],
    returns: { type: "any", description: "The first element" },
    examples: ["[1, 2, 3] /> head  -- 1"],
  },
  tail: {
    name: "tail",
    signature: "tail(list) -> [any]",
    description: "Returns all elements except the first.",
    params: [{ name: "list", type: "[any]", description: "The list" }],
    returns: { type: "[any]", description: "The list without its first element" },
    examples: ["[1, 2, 3] /> tail  -- [2, 3]"],
  },
  push: {
    name: "push",
    signature: "push(list, item) -> [any]",
    description: "Returns a new list with the item appended.",
    params: [
      { name: "list", type: "[any]", description: "The original list" },
      { name: "item", type: "any", description: "The item to append" },
    ],
    returns: { type: "[any]", description: "A new list with the item added" },
    examples: ["[1, 2] /> push(3)  -- [1, 2, 3]"],
  },
  concat: {
    name: "concat",
    signature: "concat(list1, list2) -> [any]",
    description: "Concatenates two lists.",
    params: [
      { name: "list1", type: "[any]", description: "First list" },
      { name: "list2", type: "[any]", description: "Second list" },
    ],
    returns: { type: "[any]", description: "The concatenated list" },
    examples: ["[1, 2] /> concat([3, 4])  -- [1, 2, 3, 4]"],
  },
  reverse: {
    name: "reverse",
    signature: "reverse(list) -> [any]",
    description: "Returns a reversed copy of the list.",
    params: [{ name: "list", type: "[any]", description: "The list to reverse" }],
    returns: { type: "[any]", description: "A new reversed list" },
    examples: ["[1, 2, 3] /> reverse  -- [3, 2, 1]"],
  },
  isEmpty: {
    name: "isEmpty",
    signature: "isEmpty(list | string) -> Bool",
    description: "Checks if a list or string is empty.",
    params: [{ name: "list | string", type: "[any] | String", description: "The value to check" }],
    returns: { type: "Bool", description: "True if empty" },
    examples: ["[] /> isEmpty      -- true", '[1] /> isEmpty     -- false', '"" /> isEmpty      -- true'],
  },
  fst: {
    name: "fst",
    signature: "fst(tuple | list) -> any",
    description: "Returns the first element of a tuple or list.",
    params: [{ name: "tuple | list", type: "Tuple | [any]", description: "The tuple or list" }],
    returns: { type: "any", description: "The first element" },
    examples: ["(1, 2) /> fst     -- 1", "[1, 2, 3] /> fst  -- 1"],
  },
  snd: {
    name: "snd",
    signature: "snd(tuple | list) -> any",
    description: "Returns the second element of a tuple or list.",
    params: [{ name: "tuple | list", type: "Tuple | [any]", description: "The tuple or list" }],
    returns: { type: "any", description: "The second element" },
    examples: ["(1, 2) /> snd     -- 2", "[1, 2, 3] /> snd  -- 2"],
  },
  zip: {
    name: "zip",
    signature: "zip(lists) -> [[any]]",
    description: "Zips multiple lists into a list of tuples.",
    params: [{ name: "lists", type: "[[any]]", description: "A list of lists to zip" }],
    returns: { type: "[[any]]", description: "List of zipped elements" },
    examples: ["zip([[1, 2], [3, 4]])  -- [[1, 3], [2, 4]]"],
  },
  range: {
    name: "range",
    signature: "range(end) -> [Int] | range(start, end) -> [Int]",
    description: "Creates a list of integers from start (default 0) to end (exclusive).",
    params: [
      { name: "start", type: "Int", description: "Starting value (default 0)" },
      { name: "end", type: "Int", description: "Ending value (exclusive)" },
    ],
    returns: { type: "[Int]", description: "List of integers" },
    examples: ["range(5)     -- [0, 1, 2, 3, 4]", "range(2, 5)  -- [2, 3, 4]"],
  },
  iterations: {
    name: "iterations",
    signature: "iterations(count) -> [Int]",
    description: "Creates a list of integers from 0 to count-1.",
    params: [{ name: "count", type: "Int", description: "Number of iterations" }],
    returns: { type: "[Int]", description: "List of integers" },
    examples: ["iterations(3)  -- [0, 1, 2]"],
  },
  take: {
    name: "take",
    signature: "take(list, n) -> [any]",
    description: "Returns the first n elements of a list.",
    params: [
      { name: "list", type: "[any]", description: "The list" },
      { name: "n", type: "Int", description: "Number of elements to take" },
    ],
    returns: { type: "[any]", description: "The first n elements" },
    examples: ["[1, 2, 3, 4, 5] /> take(3)  -- [1, 2, 3]"],
  },
  at: {
    name: "at",
    signature: "at(list, index) -> any",
    description: "Returns the element at the given index. Throws if out of bounds.",
    params: [
      { name: "list", type: "[any]", description: "The list" },
      { name: "index", type: "Int", description: "The index (0-based)" },
    ],
    returns: { type: "any", description: "The element at the index" },
    examples: ["[10, 20, 30] /> at(1)  -- 20"],
  },

  // Higher-order functions
  map: {
    name: "map",
    signature: "map(list, fn) -> [any]",
    description: "Applies a function to each element of a list. Callback receives (element, index).",
    params: [
      { name: "list", type: "[any]", description: "The list to map over" },
      { name: "fn", type: "(any, Int) -> any", description: "The transformation function" },
    ],
    returns: { type: "[any]", description: "A new list with transformed elements" },
    examples: [
      "[1, 2, 3] /> map((x) -> x * 2)      -- [2, 4, 6]",
      '["a", "b"] /> map((x, i) -> `{i}:{x}`)  -- ["0:a", "1:b"]',
    ],
  },
  filter: {
    name: "filter",
    signature: "filter(list, predicate) -> [any]",
    description: "Keeps elements that satisfy the predicate. Callback receives (element, index).",
    params: [
      { name: "list", type: "[any]", description: "The list to filter" },
      { name: "predicate", type: "(any, Int) -> Bool", description: "The filter function" },
    ],
    returns: { type: "[any]", description: "A new filtered list" },
    examples: [
      "[1, 2, 3, 4] /> filter((x) -> x > 2)  -- [3, 4]",
      "[10, 20, 30] /> filter((_, i) -> i < 2)  -- [10, 20]",
    ],
  },
  reduce: {
    name: "reduce",
    signature: "reduce(list, initial, fn) -> any",
    description: "Reduces a list to a single value. Callback receives (accumulator, element, index).",
    params: [
      { name: "list", type: "[any]", description: "The list to reduce" },
      { name: "initial", type: "any", description: "The initial accumulator value" },
      { name: "fn", type: "(any, any, Int) -> any", description: "The reducer function" },
    ],
    returns: { type: "any", description: "The final accumulated value" },
    examples: [
      "[1, 2, 3] /> reduce(0, (acc, x) -> acc + x)  -- 6",
      '["a", "b"] /> reduce("", (acc, x, i) -> acc ++ `{i}:{x} `)  -- "0:a 1:b "',
    ],
  },
  partition: {
    name: "partition",
    signature: "partition(list, predicate) -> [[any], [any]]",
    description: "Splits a list into two: elements matching predicate and those that don't.",
    params: [
      { name: "list", type: "[any]", description: "The list to partition" },
      { name: "predicate", type: "(any) -> Bool", description: "The partition function" },
    ],
    returns: { type: "[[any], [any]]", description: "[matching, non-matching] lists" },
    examples: ["[1, 2, 3, 4] /> partition((x) -> x > 2)  -- [[3, 4], [1, 2]]"],
  },

  // String functions
  toString: {
    name: "toString",
    signature: "toString(value) -> String",
    description: "Converts a value to its string representation.",
    params: [{ name: "value", type: "any", description: "The value to convert" }],
    returns: { type: "String", description: "String representation" },
    examples: ["42 /> toString     -- \"42\"", "[1, 2] /> toString -- \"[1, 2]\""],
  },
  split: {
    name: "split",
    signature: "split(string, delimiter) -> [String]",
    description: "Splits a string by the delimiter.",
    params: [
      { name: "string", type: "String", description: "The string to split" },
      { name: "delimiter", type: "String", description: "The delimiter" },
    ],
    returns: { type: "[String]", description: "List of substrings" },
    examples: ['"a,b,c" /> split(",")  -- ["a", "b", "c"]'],
  },
  lines: {
    name: "lines",
    signature: "lines(string) -> [String]",
    description: "Splits a string by newlines.",
    params: [{ name: "string", type: "String", description: "The string to split" }],
    returns: { type: "[String]", description: "List of lines" },
    examples: ['"a\\nb\\nc" /> lines  -- ["a", "b", "c"]'],
  },
  charAt: {
    name: "charAt",
    signature: "charAt(string, index) -> String",
    description: "Returns the character at the given index.",
    params: [
      { name: "string", type: "String", description: "The string" },
      { name: "index", type: "Int", description: "The index" },
    ],
    returns: { type: "String", description: "The character (empty string if out of bounds)" },
    examples: ['"hello" /> charAt(1)  -- "e"'],
  },
  join: {
    name: "join",
    signature: "join(list, delimiter?) -> String",
    description: "Joins a list into a string with an optional delimiter.",
    params: [
      { name: "list", type: "[any]", description: "The list to join" },
      { name: "delimiter", type: "String", description: "The delimiter (default: empty string)" },
    ],
    returns: { type: "String", description: "The joined string" },
    examples: ['["a", "b", "c"] /> join(",")  -- "a,b,c"', '[1, 2, 3] /> join()           -- "123"'],
  },
  padEnd: {
    name: "padEnd",
    signature: "padEnd(string, length, char?) -> String",
    description: "Pads the string at the end to reach the target length.",
    params: [
      { name: "string", type: "String", description: "The string to pad" },
      { name: "length", type: "Int", description: "Target length" },
      { name: "char", type: "String", description: "Pad character (default: space)" },
    ],
    returns: { type: "String", description: "The padded string" },
    examples: ['"hi" /> padEnd(5)        -- "hi   "', '"hi" /> padEnd(5, ".")   -- "hi..."'],
  },
  padStart: {
    name: "padStart",
    signature: "padStart(string, length, char?) -> String",
    description: "Pads the string at the start to reach the target length.",
    params: [
      { name: "string", type: "String", description: "The string to pad" },
      { name: "length", type: "Int", description: "Target length" },
      { name: "char", type: "String", description: "Pad character (default: space)" },
    ],
    returns: { type: "String", description: "The padded string" },
    examples: ['"5" /> padStart(3, "0")  -- "005"'],
  },
  trim: {
    name: "trim",
    signature: "trim(string) -> String",
    description: "Removes whitespace from both ends of a string.",
    params: [{ name: "string", type: "String", description: "The string to trim" }],
    returns: { type: "String", description: "The trimmed string" },
    examples: ['"  hello  " /> trim  -- "hello"'],
  },
  trimEnd: {
    name: "trimEnd",
    signature: "trimEnd(string) -> String",
    description: "Removes whitespace from the end of a string.",
    params: [{ name: "string", type: "String", description: "The string to trim" }],
    returns: { type: "String", description: "The trimmed string" },
    examples: ['"hello  " /> trimEnd  -- "hello"'],
  },
  indexOf: {
    name: "indexOf",
    signature: "indexOf(string, search) -> Int",
    description: "Returns the index of the first occurrence of search, or -1 if not found.",
    params: [
      { name: "string", type: "String", description: "The string to search in" },
      { name: "search", type: "String", description: "The substring to find" },
    ],
    returns: { type: "Int", description: "The index or -1" },
    examples: ['"hello" /> indexOf("ll")  -- 2', '"hello" /> indexOf("x")   -- -1'],
  },
  includes: {
    name: "includes",
    signature: "includes(string | list, search) -> Bool",
    description: "Checks if a string contains a substring or a list contains an element.",
    params: [
      { name: "string | list", type: "String | [any]", description: "The value to search in" },
      { name: "search", type: "any", description: "The value to find" },
    ],
    returns: { type: "Bool", description: "True if found" },
    examples: ['"hello" /> includes("ell")  -- true', "[1, 2, 3] /> includes(2)    -- true"],
  },
  repeat: {
    name: "repeat",
    signature: "repeat(string, count) -> String",
    description: "Repeats a string n times.",
    params: [
      { name: "string", type: "String", description: "The string to repeat" },
      { name: "count", type: "Int", description: "Number of repetitions" },
    ],
    returns: { type: "String", description: "The repeated string" },
    examples: ['"ab" /> repeat(3)  -- "ababab"'],
  },
  slice: {
    name: "slice",
    signature: "slice(string | list, start, end?) -> String | [any]",
    description: "Extracts a portion of a string or list.",
    params: [
      { name: "string | list", type: "String | [any]", description: "The value to slice" },
      { name: "start", type: "Int", description: "Start index" },
      { name: "end", type: "Int", description: "End index (exclusive, optional)" },
    ],
    returns: { type: "String | [any]", description: "The sliced portion" },
    examples: ['"hello" /> slice(1, 4)     -- "ell"', "[1, 2, 3, 4] /> slice(1, 3) -- [2, 3]"],
  },
  chars: {
    name: "chars",
    signature: "chars(string) -> [String]",
    description: "Splits a string into a list of characters.",
    params: [{ name: "string", type: "String", description: "The string to split" }],
    returns: { type: "[String]", description: "List of characters" },
    examples: ['"abc" /> chars  -- ["a", "b", "c"]'],
  },
  toUpperCase: {
    name: "toUpperCase",
    signature: "toUpperCase(string) -> String",
    description: "Converts a string to uppercase.",
    params: [{ name: "string", type: "String", description: "The string to convert" }],
    returns: { type: "String", description: "The uppercase string" },
    examples: ['"hello" /> toUpperCase  -- "HELLO"'],
  },
  toLowerCase: {
    name: "toLowerCase",
    signature: "toLowerCase(string) -> String",
    description: "Converts a string to lowercase.",
    params: [{ name: "string", type: "String", description: "The string to convert" }],
    returns: { type: "String", description: "The lowercase string" },
    examples: ['"HELLO" /> toLowerCase  -- "hello"'],
  },
  replace: {
    name: "replace",
    signature: "replace(string, search, replacement) -> String",
    description: "Replaces all occurrences of search with replacement.",
    params: [
      { name: "string", type: "String", description: "The string to modify" },
      { name: "search", type: "String", description: "The substring to find" },
      { name: "replacement", type: "String", description: "The replacement string" },
    ],
    returns: { type: "String", description: "The modified string" },
    examples: ['"a-b-c" /> replace("-", "_")  -- "a_b_c"'],
  },
  replaceFirst: {
    name: "replaceFirst",
    signature: "replaceFirst(string, search, replacement) -> String",
    description: "Replaces the first occurrence of search with replacement.",
    params: [
      { name: "string", type: "String", description: "The string to modify" },
      { name: "search", type: "String", description: "The substring to find" },
      { name: "replacement", type: "String", description: "The replacement string" },
    ],
    returns: { type: "String", description: "The modified string" },
    examples: ['"a-b-c" /> replaceFirst("-", "_")  -- "a_b-c"'],
  },
  startsWith: {
    name: "startsWith",
    signature: "startsWith(string, prefix) -> Bool",
    description: "Checks if a string starts with the given prefix.",
    params: [
      { name: "string", type: "String", description: "The string to check" },
      { name: "prefix", type: "String", description: "The prefix to look for" },
    ],
    returns: { type: "Bool", description: "True if string starts with prefix" },
    examples: ['"hello" /> startsWith("he")  -- true', '"hello" /> startsWith("lo")  -- false'],
  },
  endsWith: {
    name: "endsWith",
    signature: "endsWith(string, suffix) -> Bool",
    description: "Checks if a string ends with the given suffix.",
    params: [
      { name: "string", type: "String", description: "The string to check" },
      { name: "suffix", type: "String", description: "The suffix to look for" },
    ],
    returns: { type: "Bool", description: "True if string ends with suffix" },
    examples: ['"hello" /> endsWith("lo")  -- true', '"hello" /> endsWith("he")  -- false'],
  },

  // Set operations
  listSet: {
    name: "listSet",
    signature: "listSet(list) -> [any]",
    description: "Creates a list with unique elements (removes duplicates).",
    params: [{ name: "list", type: "[any]", description: "The list to deduplicate" }],
    returns: { type: "[any]", description: "List with unique elements" },
    examples: ["[1, 2, 2, 3, 1] /> listSet  -- [1, 2, 3]"],
  },
  setAdd: {
    name: "setAdd",
    signature: "setAdd(list, item) -> [any]",
    description: "Adds an item to a list if not already present.",
    params: [
      { name: "list", type: "[any]", description: "The list" },
      { name: "item", type: "any", description: "The item to add" },
    ],
    returns: { type: "[any]", description: "New list with item added (if unique)" },
    examples: ["[1, 2] /> setAdd(3)  -- [1, 2, 3]", "[1, 2] /> setAdd(2)  -- [1, 2]"],
  },
  setHas: {
    name: "setHas",
    signature: "setHas(list, item) -> Bool",
    description: "Checks if an item exists in a list.",
    params: [
      { name: "list", type: "[any]", description: "The list" },
      { name: "item", type: "any", description: "The item to check" },
    ],
    returns: { type: "Bool", description: "True if item exists" },
    examples: ["[1, 2, 3] /> setHas(2)  -- true", "[1, 2, 3] /> setHas(5)  -- false"],
  },

  // Async functions
  delay: {
    name: "delay",
    signature: "delay(ms, value?) -> Promise",
    description: "Returns a promise that resolves after ms milliseconds with the optional value.",
    params: [
      { name: "ms", type: "Int", description: "Milliseconds to wait" },
      { name: "value", type: "any", description: "Value to resolve with (optional)" },
    ],
    returns: { type: "Promise", description: "A promise that resolves after the delay" },
    examples: ["await delay(1000)  -- waits 1 second", 'await delay(500, "done")  -- waits 500ms, returns "done"'],
  },
  parallel: {
    name: "parallel",
    signature: "parallel(list, fn, options?) -> Promise<[any]>",
    description: "Executes a function on each list element concurrently. Callback receives (element, index).",
    params: [
      { name: "list", type: "[any]", description: "The list to process" },
      { name: "fn", type: "(any, Int) -> any", description: "The async function to apply" },
      { name: "options", type: "{ limit?: Int }", description: "Optional concurrency limit" },
    ],
    returns: { type: "Promise<[any]>", description: "Promise resolving to results" },
    examples: [
      "await parallel([1, 2, 3], (x) -> delay(100, x * 2))  -- [2, 4, 6]",
      "await parallel(urls, fetch, { limit: 5 })  -- max 5 concurrent requests",
    ],
  },
  race: {
    name: "race",
    signature: "race(thunks) -> Promise",
    description: "Returns the result of the first promise to resolve.",
    params: [{ name: "thunks", type: "[() -> Promise]", description: "List of functions returning promises" }],
    returns: { type: "Promise", description: "The first resolved value" },
    examples: ["await race([() -> delay(100, 1), () -> delay(50, 2)])  -- 2"],
  },
  then: {
    name: "then",
    signature: "then(promise, fn) -> Promise",
    description: "Chains a transformation on a promise.",
    params: [
      { name: "promise", type: "Promise", description: "The promise to chain" },
      { name: "fn", type: "(any) -> any", description: "The transformation function" },
    ],
    returns: { type: "Promise", description: "A new promise with the transformed value" },
    examples: ["delay(100, 5) /> then((x) -> x * 2)  -- Promise resolving to 10"],
  },

  // I/O functions
  readFile: {
    name: "readFile",
    signature: "readFile(path) -> Promise<String>",
    description: "Reads a file asynchronously and returns its contents as a string.",
    params: [{ name: "path", type: "String", description: "The file path" }],
    returns: { type: "Promise<String>", description: "The file contents" },
    examples: ['let content = await readFile("./data.txt")'],
  },
  writeFile: {
    name: "writeFile",
    signature: "writeFile(path, content) -> Promise<Bool>",
    description: "Writes content to a file asynchronously.",
    params: [
      { name: "path", type: "String", description: "The file path" },
      { name: "content", type: "String", description: "The content to write" },
    ],
    returns: { type: "Promise<Bool>", description: "True on success" },
    examples: ['await writeFile("./output.txt", "Hello!")'],
  },
  appendFile: {
    name: "appendFile",
    signature: "appendFile(path, content) -> Promise<Bool>",
    description: "Appends content to a file asynchronously.",
    params: [
      { name: "path", type: "String", description: "The file path" },
      { name: "content", type: "String", description: "The content to append" },
    ],
    returns: { type: "Promise<Bool>", description: "True on success" },
    examples: ['await appendFile("./log.txt", "New line\\n")'],
  },
  fileExists: {
    name: "fileExists",
    signature: "fileExists(path) -> Promise<Bool>",
    description: "Checks if a file exists asynchronously.",
    params: [{ name: "path", type: "String", description: "The file path" }],
    returns: { type: "Promise<Bool>", description: "True if file exists" },
    examples: ['let exists = await fileExists("./config.json")'],
  },
  deleteFile: {
    name: "deleteFile",
    signature: "deleteFile(path) -> Promise<Bool>",
    description: "Deletes a file asynchronously.",
    params: [{ name: "path", type: "String", description: "The file path" }],
    returns: { type: "Promise<Bool>", description: "True on success" },
    examples: ['await deleteFile("./temp.txt")'],
  },
  readDir: {
    name: "readDir",
    signature: "readDir(path) -> Promise<[String]>",
    description: "Reads a directory and returns a list of filenames.",
    params: [{ name: "path", type: "String", description: "The directory path" }],
    returns: { type: "Promise<[String]>", description: "List of filenames" },
    examples: ['let files = await readDir("./src")'],
  },
  fetch: {
    name: "fetch",
    signature: "fetch(url, options?) -> Promise<Response>",
    description: "Makes an HTTP request asynchronously.",
    params: [
      { name: "url", type: "String", description: "The URL to fetch" },
      { name: "options", type: "{ method?: String, headers?: Record, body?: any }", description: "Request options" },
    ],
    returns: { type: "Promise<Response>", description: "Response with status, ok, body, headers" },
    examples: [
      'let response = await fetch("https://api.example.com/data")',
      'let response = await fetch("https://api.example.com/data", { method: "POST", body: { name: "Max" } })',
    ],
  },

  // ASCII diagram
  breakPieces: {
    name: "breakPieces",
    signature: "breakPieces(shape) -> [String]",
    description: "Parses an ASCII diagram into minimal closed pieces.",
    params: [{ name: "shape", type: "String", description: "ASCII art diagram" }],
    returns: { type: "[String]", description: "List of individual pieces" },
    examples: ["breakPieces(\"+--+\\n|  |\\n+--+\")"],
  },

  // JSON functions
  parseJson: {
    name: "parseJson",
    signature: "parseJson(string) -> any",
    description: "Parses a JSON string into a Lea value.",
    params: [{ name: "string", type: "String", description: "The JSON string to parse" }],
    returns: { type: "any", description: "The parsed value (record, list, string, number, boolean, or null)" },
    examples: [
      '{ name: "Bob" } /> toJson /> parseJson  -- { name: "Bob" }',
      "[1, 2, 3] /> toJson /> parseJson  -- [1, 2, 3]",
    ],
  },
  toJson: {
    name: "toJson",
    signature: "toJson(value, indent?) -> String",
    description: "Converts a Lea value to a JSON string.",
    params: [
      { name: "value", type: "any", description: "The value to convert" },
      { name: "indent", type: "Int", description: "Optional indentation spaces" },
    ],
    returns: { type: "String", description: "The JSON string" },
    examples: [
      '{ name: "Bob" } /> toJson  -- \'{"name":"Bob"}\'',
      "{ a: 1 } /> toJson(2)  -- formatted with 2 spaces",
    ],
  },
  prettyJson: {
    name: "prettyJson",
    signature: "prettyJson(value) -> String",
    description: "Converts a Lea value to a pretty-printed JSON string (2-space indent).",
    params: [{ name: "value", type: "any", description: "The value to convert" }],
    returns: { type: "String", description: "The formatted JSON string" },
    examples: ["{ name: \"Bob\", age: 30 } /> prettyJson"],
  },

  // Date/time functions
  now: {
    name: "now",
    signature: "now() -> Int",
    description: "Returns the current timestamp in milliseconds since Unix epoch.",
    params: [],
    returns: { type: "Int", description: "Current timestamp in milliseconds" },
    examples: ["now()  -- 1702500000000"],
  },
  today: {
    name: "today",
    signature: "today() -> Record",
    description: "Returns the current date/time as a record with year, month, day, etc.",
    params: [],
    returns: { type: "Record", description: "Date record with year, month, day, hour, minute, second, millisecond, dayOfWeek, timestamp" },
    examples: ["today()  -- { year: 2024, month: 12, day: 10, ... }"],
  },
  date: {
    name: "date",
    signature: "date(timestamp) | date(string) | date(year, month, day, ...) -> Record",
    description: "Creates a date record from a timestamp, date string, or components.",
    params: [
      { name: "timestamp", type: "Int", description: "Unix timestamp in milliseconds" },
      { name: "string", type: "String", description: "Date string (e.g., \"2024-01-15\")" },
      { name: "year, month, day, ...", type: "Int", description: "Date components (hour, minute, second, ms optional)" },
    ],
    returns: { type: "Record", description: "Date record" },
    examples: [
      "date(1702500000000)  -- date from timestamp",
      'date("2024-01-15")   -- date from string',
      "date(2024, 6, 15)    -- June 15, 2024",
    ],
  },
  formatDate: {
    name: "formatDate",
    signature: "formatDate(date, format?) -> String",
    description: "Formats a date record or timestamp as a string.",
    params: [
      { name: "date", type: "Record | Int", description: "Date record or timestamp" },
      { name: "format", type: "String", description: "Format string: \"ISO\", \"date\", \"time\", \"locale\", or custom (YYYY, MM, DD, HH, mm, ss)" },
    ],
    returns: { type: "String", description: "Formatted date string" },
    examples: [
      'today() /> formatDate("ISO")        -- "2024-12-10T..."',
      'today() /> formatDate("YYYY-MM-DD") -- "2024-12-10"',
    ],
  },
  parseDate: {
    name: "parseDate",
    signature: "parseDate(string) -> Record",
    description: "Parses a date string into a date record.",
    params: [{ name: "string", type: "String", description: "Date string to parse" }],
    returns: { type: "Record", description: "Date record" },
    examples: ['parseDate("2024-01-15")  -- { year: 2024, month: 1, day: 15, ... }'],
  },
  addDays: {
    name: "addDays",
    signature: "addDays(date, days) -> Record",
    description: "Adds days to a date and returns a new date record.",
    params: [
      { name: "date", type: "Record | Int", description: "Date record or timestamp" },
      { name: "days", type: "Int", description: "Number of days to add (can be negative)" },
    ],
    returns: { type: "Record", description: "New date record" },
    examples: ["date(2024, 1, 15) /> addDays(10)  -- { year: 2024, month: 1, day: 25, ... }"],
  },
  addHours: {
    name: "addHours",
    signature: "addHours(date, hours) -> Record",
    description: "Adds hours to a date and returns a new date record.",
    params: [
      { name: "date", type: "Record | Int", description: "Date record or timestamp" },
      { name: "hours", type: "Int", description: "Number of hours to add (can be negative)" },
    ],
    returns: { type: "Record", description: "New date record" },
    examples: ["date(2024, 1, 15, 10, 0) /> addHours(5)  -- hour becomes 15"],
  },
  addMinutes: {
    name: "addMinutes",
    signature: "addMinutes(date, minutes) -> Record",
    description: "Adds minutes to a date and returns a new date record.",
    params: [
      { name: "date", type: "Record | Int", description: "Date record or timestamp" },
      { name: "minutes", type: "Int", description: "Number of minutes to add (can be negative)" },
    ],
    returns: { type: "Record", description: "New date record" },
    examples: ["date(2024, 1, 15, 10, 30) /> addMinutes(45)  -- minute becomes 15 (next hour)"],
  },
  diffDates: {
    name: "diffDates",
    signature: "diffDates(date1, date2) -> Int",
    description: "Returns the difference between two dates in milliseconds.",
    params: [
      { name: "date1", type: "Record | Int", description: "First date" },
      { name: "date2", type: "Record | Int", description: "Second date" },
    ],
    returns: { type: "Int", description: "Difference in milliseconds (date1 - date2)" },
    examples: [
      "let d1 = date(2024, 1, 15)",
      "let d2 = date(2024, 1, 10)",
      "diffDates(d1, d2) / (24 * 60 * 60 * 1000)  -- 5 (days)",
    ],
  },

  // ===== New Collection Operations =====
  find: {
    name: "find",
    signature: "find(list, predicate) -> any | null",
    description: "Finds the first element matching the predicate. Returns null if not found.",
    params: [
      { name: "list", type: "[any]", description: "The list to search" },
      { name: "predicate", type: "(any, Int) -> Bool", description: "The predicate function" },
    ],
    returns: { type: "any | null", description: "The first matching element or null" },
    examples: ["[1, 2, 3, 4] /> find((x) -> x > 2)  -- 3"],
  },
  findIndex: {
    name: "findIndex",
    signature: "findIndex(list, predicate) -> Int",
    description: "Finds the index of the first element matching the predicate. Returns -1 if not found.",
    params: [
      { name: "list", type: "[any]", description: "The list to search" },
      { name: "predicate", type: "(any, Int) -> Bool", description: "The predicate function" },
    ],
    returns: { type: "Int", description: "The index or -1" },
    examples: ["[1, 2, 3, 4] /> findIndex((x) -> x > 2)  -- 2"],
  },
  some: {
    name: "some",
    signature: "some(list, predicate) -> Bool",
    description: "Checks if any element matches the predicate.",
    params: [
      { name: "list", type: "[any]", description: "The list to check" },
      { name: "predicate", type: "(any, Int) -> Bool", description: "The predicate function" },
    ],
    returns: { type: "Bool", description: "True if any element matches" },
    examples: ["[1, 2, 3] /> some((x) -> x > 2)  -- true"],
  },
  every: {
    name: "every",
    signature: "every(list, predicate) -> Bool",
    description: "Checks if all elements match the predicate.",
    params: [
      { name: "list", type: "[any]", description: "The list to check" },
      { name: "predicate", type: "(any, Int) -> Bool", description: "The predicate function" },
    ],
    returns: { type: "Bool", description: "True if all elements match" },
    examples: ["[2, 4, 6] /> every((x) -> x > 0)  -- true"],
  },
  sort: {
    name: "sort",
    signature: "sort(list, comparator?) -> [any]",
    description: "Sorts a list. Without comparator: numbers numerically, strings lexically.",
    params: [
      { name: "list", type: "[any]", description: "The list to sort" },
      { name: "comparator", type: "(any, any) -> Int", description: "Optional comparator function" },
    ],
    returns: { type: "[any]", description: "A new sorted list" },
    examples: ["[3, 1, 4] /> sort  -- [1, 3, 4]", "[3, 1, 4] /> sort((a, b) -> b - a)  -- [4, 3, 1]"],
  },
  groupBy: {
    name: "groupBy",
    signature: "groupBy(list, keyFn) -> Record",
    description: "Groups elements by key function. Returns a record with keys and arrays of elements.",
    params: [
      { name: "list", type: "[any]", description: "The list to group" },
      { name: "keyFn", type: "(any, Int) -> any", description: "Function to extract the key" },
    ],
    returns: { type: "Record", description: "Record with grouped elements" },
    examples: ['[1, 2, 3, 4] /> groupBy((x) -> x > 2)  -- { "false": [1, 2], "true": [3, 4] }'],
  },
  flatten: {
    name: "flatten",
    signature: "flatten(list, depth?) -> [any]",
    description: "Flattens nested lists by the specified depth (default: 1).",
    params: [
      { name: "list", type: "[[any]]", description: "The nested list" },
      { name: "depth", type: "Int", description: "How deep to flatten (default: 1)" },
    ],
    returns: { type: "[any]", description: "The flattened list" },
    examples: ["[[1, 2], [3, 4]] /> flatten  -- [1, 2, 3, 4]"],
  },
  flatMap: {
    name: "flatMap",
    signature: "flatMap(list, fn) -> [any]",
    description: "Maps each element then flattens by one level.",
    params: [
      { name: "list", type: "[any]", description: "The list" },
      { name: "fn", type: "(any, Int) -> [any]", description: "Function returning a list" },
    ],
    returns: { type: "[any]", description: "The flattened mapped list" },
    examples: ["[1, 2] /> flatMap((x) -> [x, x * 2])  -- [1, 2, 2, 4]"],
  },
  last: {
    name: "last",
    signature: "last(list) -> any",
    description: "Returns the last element of a list. Throws if empty.",
    params: [{ name: "list", type: "[any]", description: "The list" }],
    returns: { type: "any", description: "The last element" },
    examples: ["[1, 2, 3] /> last  -- 3"],
  },
  drop: {
    name: "drop",
    signature: "drop(list, n) -> [any]",
    description: "Drops the first n elements from a list.",
    params: [
      { name: "list", type: "[any]", description: "The list" },
      { name: "n", type: "Int", description: "Number of elements to drop" },
    ],
    returns: { type: "[any]", description: "The remaining elements" },
    examples: ["[1, 2, 3, 4] /> drop(2)  -- [3, 4]"],
  },
  takeWhile: {
    name: "takeWhile",
    signature: "takeWhile(list, predicate) -> [any]",
    description: "Takes elements while the predicate is true.",
    params: [
      { name: "list", type: "[any]", description: "The list" },
      { name: "predicate", type: "(any, Int) -> Bool", description: "The predicate function" },
    ],
    returns: { type: "[any]", description: "Elements until predicate fails" },
    examples: ["[1, 2, 3, 4, 1] /> takeWhile((x) -> x < 4)  -- [1, 2, 3]"],
  },
  dropWhile: {
    name: "dropWhile",
    signature: "dropWhile(list, predicate) -> [any]",
    description: "Drops elements while the predicate is true.",
    params: [
      { name: "list", type: "[any]", description: "The list" },
      { name: "predicate", type: "(any, Int) -> Bool", description: "The predicate function" },
    ],
    returns: { type: "[any]", description: "Elements after predicate fails" },
    examples: ["[1, 2, 3, 4, 1] /> dropWhile((x) -> x < 3)  -- [3, 4, 1]"],
  },
  count: {
    name: "count",
    signature: "count(list, predicate?) -> Int",
    description: "Counts elements, optionally filtering by predicate.",
    params: [
      { name: "list", type: "[any]", description: "The list" },
      { name: "predicate", type: "(any, Int) -> Bool", description: "Optional filter function" },
    ],
    returns: { type: "Int", description: "The count" },
    examples: ["[1, 2, 3, 4] /> count  -- 4", "[1, 2, 3, 4] /> count((x) -> x > 2)  -- 2"],
  },
  intersperse: {
    name: "intersperse",
    signature: "intersperse(list, separator) -> [any]",
    description: "Inserts separator between each element.",
    params: [
      { name: "list", type: "[any]", description: "The list" },
      { name: "separator", type: "any", description: "The separator to insert" },
    ],
    returns: { type: "[any]", description: "List with separators" },
    examples: ["[1, 2, 3] /> intersperse(0)  -- [1, 0, 2, 0, 3]"],
  },
  enumerate: {
    name: "enumerate",
    signature: "enumerate(list, start?) -> [[Int, any]]",
    description: "Creates pairs of [index, element].",
    params: [
      { name: "list", type: "[any]", description: "The list" },
      { name: "start", type: "Int", description: "Starting index (default: 0)" },
    ],
    returns: { type: "[[Int, any]]", description: "List of [index, element] pairs" },
    examples: ['["a", "b"] /> enumerate  -- [[0, "a"], [1, "b"]]'],
  },
  transpose: {
    name: "transpose",
    signature: "transpose(matrix) -> [[any]]",
    description: "Transposes a matrix (list of lists).",
    params: [{ name: "matrix", type: "[[any]]", description: "The matrix to transpose" }],
    returns: { type: "[[any]]", description: "The transposed matrix" },
    examples: ["[[1, 2], [3, 4]] /> transpose  -- [[1, 3], [2, 4]]"],
  },

  // ===== Bitwise Operations =====
  bitAnd: {
    name: "bitAnd",
    signature: "bitAnd(a, b) -> Int",
    description: "Bitwise AND operation.",
    params: [
      { name: "a", type: "Int", description: "First operand" },
      { name: "b", type: "Int", description: "Second operand" },
    ],
    returns: { type: "Int", description: "Bitwise AND result" },
    examples: ["bitAnd(5, 3)  -- 1 (0101 & 0011 = 0001)"],
  },
  bitOr: {
    name: "bitOr",
    signature: "bitOr(a, b) -> Int",
    description: "Bitwise OR operation.",
    params: [
      { name: "a", type: "Int", description: "First operand" },
      { name: "b", type: "Int", description: "Second operand" },
    ],
    returns: { type: "Int", description: "Bitwise OR result" },
    examples: ["bitOr(5, 3)  -- 7 (0101 | 0011 = 0111)"],
  },
  bitXor: {
    name: "bitXor",
    signature: "bitXor(a, b) -> Int",
    description: "Bitwise XOR operation.",
    params: [
      { name: "a", type: "Int", description: "First operand" },
      { name: "b", type: "Int", description: "Second operand" },
    ],
    returns: { type: "Int", description: "Bitwise XOR result" },
    examples: ["bitXor(5, 3)  -- 6 (0101 ^ 0011 = 0110)"],
  },
  bitNot: {
    name: "bitNot",
    signature: "bitNot(a) -> Int",
    description: "Bitwise NOT operation.",
    params: [{ name: "a", type: "Int", description: "The operand" }],
    returns: { type: "Int", description: "Bitwise NOT result" },
    examples: ["bitNot(5)  -- -6"],
  },
  bitShiftLeft: {
    name: "bitShiftLeft",
    signature: "bitShiftLeft(a, n) -> Int",
    description: "Shifts bits left by n positions.",
    params: [
      { name: "a", type: "Int", description: "The value to shift" },
      { name: "n", type: "Int", description: "Number of positions" },
    ],
    returns: { type: "Int", description: "Shifted value" },
    examples: ["bitShiftLeft(1, 3)  -- 8"],
  },
  bitShiftRight: {
    name: "bitShiftRight",
    signature: "bitShiftRight(a, n) -> Int",
    description: "Shifts bits right by n positions (signed).",
    params: [
      { name: "a", type: "Int", description: "The value to shift" },
      { name: "n", type: "Int", description: "Number of positions" },
    ],
    returns: { type: "Int", description: "Shifted value" },
    examples: ["bitShiftRight(8, 2)  -- 2"],
  },

  // ===== Statistics =====
  sum: {
    name: "sum",
    signature: "sum(list) -> Number",
    description: "Sums all elements in a list.",
    params: [{ name: "list", type: "[Number]", description: "List of numbers" }],
    returns: { type: "Number", description: "The sum" },
    examples: ["[1, 2, 3, 4] /> sum  -- 10"],
  },
  product: {
    name: "product",
    signature: "product(list) -> Number",
    description: "Multiplies all elements in a list.",
    params: [{ name: "list", type: "[Number]", description: "List of numbers" }],
    returns: { type: "Number", description: "The product" },
    examples: ["[1, 2, 3, 4] /> product  -- 24"],
  },
  mean: {
    name: "mean",
    signature: "mean(list) -> Number",
    description: "Computes the arithmetic mean (average).",
    params: [{ name: "list", type: "[Number]", description: "List of numbers" }],
    returns: { type: "Number", description: "The mean" },
    examples: ["[1, 2, 3, 4, 5] /> mean  -- 3"],
  },
  median: {
    name: "median",
    signature: "median(list) -> Number",
    description: "Computes the median value.",
    params: [{ name: "list", type: "[Number]", description: "List of numbers" }],
    returns: { type: "Number", description: "The median" },
    examples: ["[1, 3, 5, 7, 9] /> median  -- 5", "[1, 2, 3, 4] /> median  -- 2.5"],
  },
  variance: {
    name: "variance",
    signature: "variance(list) -> Number",
    description: "Computes the population variance.",
    params: [{ name: "list", type: "[Number]", description: "List of numbers" }],
    returns: { type: "Number", description: "The variance" },
    examples: ["[2, 4, 4, 4, 5, 5, 7, 9] /> variance  -- 4"],
  },
  stdDev: {
    name: "stdDev",
    signature: "stdDev(list) -> Number",
    description: "Computes the population standard deviation.",
    params: [{ name: "list", type: "[Number]", description: "List of numbers" }],
    returns: { type: "Number", description: "The standard deviation" },
    examples: ["[2, 4, 4, 4, 5, 5, 7, 9] /> stdDev  -- 2"],
  },

  // ===== Number Theory =====
  gcd: {
    name: "gcd",
    signature: "gcd(a, b) -> Int",
    description: "Computes the greatest common divisor.",
    params: [
      { name: "a", type: "Int", description: "First number" },
      { name: "b", type: "Int", description: "Second number" },
    ],
    returns: { type: "Int", description: "The GCD" },
    examples: ["gcd(48, 18)  -- 6"],
  },
  lcm: {
    name: "lcm",
    signature: "lcm(a, b) -> Int",
    description: "Computes the least common multiple.",
    params: [
      { name: "a", type: "Int", description: "First number" },
      { name: "b", type: "Int", description: "Second number" },
    ],
    returns: { type: "Int", description: "The LCM" },
    examples: ["lcm(4, 6)  -- 12"],
  },
  isPrime: {
    name: "isPrime",
    signature: "isPrime(n) -> Bool",
    description: "Checks if a number is prime.",
    params: [{ name: "n", type: "Int", description: "The number to check" }],
    returns: { type: "Bool", description: "True if prime" },
    examples: ["isPrime(7)  -- true", "isPrime(6)  -- false"],
  },
  factorial: {
    name: "factorial",
    signature: "factorial(n) -> Int",
    description: "Computes n factorial (n!).",
    params: [{ name: "n", type: "Int", description: "Non-negative integer" }],
    returns: { type: "Int", description: "n!" },
    examples: ["factorial(5)  -- 120"],
  },
  fibonacci: {
    name: "fibonacci",
    signature: "fibonacci(n) -> Int",
    description: "Computes the nth Fibonacci number.",
    params: [{ name: "n", type: "Int", description: "Which Fibonacci number (0-indexed)" }],
    returns: { type: "Int", description: "The nth Fibonacci number" },
    examples: ["fibonacci(10)  -- 55"],
  },
  isEven: {
    name: "isEven",
    signature: "isEven(n) -> Bool",
    description: "Checks if a number is even.",
    params: [{ name: "n", type: "Int", description: "The number" }],
    returns: { type: "Bool", description: "True if even" },
    examples: ["isEven(4)  -- true", "isEven(3)  -- false"],
  },
  isOdd: {
    name: "isOdd",
    signature: "isOdd(n) -> Bool",
    description: "Checks if a number is odd.",
    params: [{ name: "n", type: "Int", description: "The number" }],
    returns: { type: "Bool", description: "True if odd" },
    examples: ["isOdd(3)  -- true", "isOdd(4)  -- false"],
  },
  mod: {
    name: "mod",
    signature: "mod(a, b) -> Int",
    description: "Modulo operation that handles negative numbers correctly.",
    params: [
      { name: "a", type: "Int", description: "Dividend" },
      { name: "b", type: "Int", description: "Divisor" },
    ],
    returns: { type: "Int", description: "The remainder (always positive)" },
    examples: ["mod(-5, 3)  -- 1", "mod(5, 3)  -- 2"],
  },
  divInt: {
    name: "divInt",
    signature: "divInt(a, b) -> Int",
    description: "Integer division (truncates toward zero).",
    params: [
      { name: "a", type: "Int", description: "Dividend" },
      { name: "b", type: "Int", description: "Divisor" },
    ],
    returns: { type: "Int", description: "Integer quotient" },
    examples: ["divInt(7, 3)  -- 2", "divInt(-7, 3)  -- -2"],
  },

  // ===== Regex =====
  regexTest: {
    name: "regexTest",
    signature: "regexTest(string, pattern, flags?) -> Bool",
    description: "Tests if a string matches a regex pattern.",
    params: [
      { name: "string", type: "String", description: "The string to test" },
      { name: "pattern", type: "String", description: "The regex pattern" },
      { name: "flags", type: "String", description: "Regex flags (e.g., \"i\" for case-insensitive)" },
    ],
    returns: { type: "Bool", description: "True if matches" },
    examples: ['regexTest("hello123", "[0-9]+")  -- true'],
  },
  regexMatch: {
    name: "regexMatch",
    signature: "regexMatch(string, pattern, flags?) -> Record | null",
    description: "Finds the first match. Returns { match, index, groups } or null.",
    params: [
      { name: "string", type: "String", description: "The string to search" },
      { name: "pattern", type: "String", description: "The regex pattern" },
      { name: "flags", type: "String", description: "Regex flags" },
    ],
    returns: { type: "Record | null", description: "Match info or null" },
    examples: ['regexMatch("hello123", "[0-9]+")  -- { match: "123", index: 5, groups: [] }'],
  },
  regexMatchAll: {
    name: "regexMatchAll",
    signature: "regexMatchAll(string, pattern, flags?) -> [Record]",
    description: "Finds all matches. Returns list of { match, index, groups }.",
    params: [
      { name: "string", type: "String", description: "The string to search" },
      { name: "pattern", type: "String", description: "The regex pattern" },
      { name: "flags", type: "String", description: "Regex flags" },
    ],
    returns: { type: "[Record]", description: "List of match records" },
    examples: ['regexMatchAll("a1b2c3", "[0-9]")  -- 3 matches'],
  },
  regexReplace: {
    name: "regexReplace",
    signature: "regexReplace(string, pattern, replacement, flags?) -> String",
    description: "Replaces matches with replacement string. Global by default.",
    params: [
      { name: "string", type: "String", description: "The string to modify" },
      { name: "pattern", type: "String", description: "The regex pattern" },
      { name: "replacement", type: "String", description: "The replacement string" },
      { name: "flags", type: "String", description: "Regex flags (default: \"g\")" },
    ],
    returns: { type: "String", description: "Modified string" },
    examples: ['regexReplace("a1b2", "[0-9]", "X")  -- "aXbX"'],
  },
  regexSplit: {
    name: "regexSplit",
    signature: "regexSplit(string, pattern, flags?) -> [String]",
    description: "Splits string by regex pattern.",
    params: [
      { name: "string", type: "String", description: "The string to split" },
      { name: "pattern", type: "String", description: "The regex pattern" },
      { name: "flags", type: "String", description: "Regex flags" },
    ],
    returns: { type: "[String]", description: "List of substrings" },
    examples: ['regexSplit("a1b2c", "[0-9]")  -- ["a", "b", "c"]'],
  },

  // ===== Case Conversions =====
  toCamelCase: {
    name: "toCamelCase",
    signature: "toCamelCase(string) -> String",
    description: "Converts to camelCase.",
    params: [{ name: "string", type: "String", description: "The string to convert" }],
    returns: { type: "String", description: "camelCase string" },
    examples: ['toCamelCase("hello_world")  -- "helloWorld"'],
  },
  toPascalCase: {
    name: "toPascalCase",
    signature: "toPascalCase(string) -> String",
    description: "Converts to PascalCase.",
    params: [{ name: "string", type: "String", description: "The string to convert" }],
    returns: { type: "String", description: "PascalCase string" },
    examples: ['toPascalCase("hello_world")  -- "HelloWorld"'],
  },
  toSnakeCase: {
    name: "toSnakeCase",
    signature: "toSnakeCase(string) -> String",
    description: "Converts to snake_case.",
    params: [{ name: "string", type: "String", description: "The string to convert" }],
    returns: { type: "String", description: "snake_case string" },
    examples: ['toSnakeCase("helloWorld")  -- "hello_world"'],
  },
  toKebabCase: {
    name: "toKebabCase",
    signature: "toKebabCase(string) -> String",
    description: "Converts to kebab-case.",
    params: [{ name: "string", type: "String", description: "The string to convert" }],
    returns: { type: "String", description: "kebab-case string" },
    examples: ['toKebabCase("helloWorld")  -- "hello-world"'],
  },
  toConstantCase: {
    name: "toConstantCase",
    signature: "toConstantCase(string) -> String",
    description: "Converts to CONSTANT_CASE.",
    params: [{ name: "string", type: "String", description: "The string to convert" }],
    returns: { type: "String", description: "CONSTANT_CASE string" },
    examples: ['toConstantCase("helloWorld")  -- "HELLO_WORLD"'],
  },
  capitalize: {
    name: "capitalize",
    signature: "capitalize(string) -> String",
    description: "Capitalizes the first letter.",
    params: [{ name: "string", type: "String", description: "The string" }],
    returns: { type: "String", description: "Capitalized string" },
    examples: ['capitalize("hello")  -- "Hello"'],
  },
  titleCase: {
    name: "titleCase",
    signature: "titleCase(string) -> String",
    description: "Capitalizes the first letter of each word.",
    params: [{ name: "string", type: "String", description: "The string" }],
    returns: { type: "String", description: "Title Case string" },
    examples: ['titleCase("hello world")  -- "Hello World"'],
  },
  trimStart: {
    name: "trimStart",
    signature: "trimStart(string) -> String",
    description: "Removes whitespace from the start of a string.",
    params: [{ name: "string", type: "String", description: "The string to trim" }],
    returns: { type: "String", description: "The trimmed string" },
    examples: ['"  hello" /> trimStart  -- "hello"'],
  },

  // ===== Encoding =====
  base64Encode: {
    name: "base64Encode",
    signature: "base64Encode(string) -> String",
    description: "Encodes a string to base64.",
    params: [{ name: "string", type: "String", description: "The string to encode" }],
    returns: { type: "String", description: "Base64 encoded string" },
    examples: ['base64Encode("hello")  -- "aGVsbG8="'],
  },
  base64Decode: {
    name: "base64Decode",
    signature: "base64Decode(string) -> String",
    description: "Decodes a base64 string.",
    params: [{ name: "string", type: "String", description: "The base64 string" }],
    returns: { type: "String", description: "Decoded string" },
    examples: ['base64Decode("aGVsbG8=")  -- "hello"'],
  },
  urlEncode: {
    name: "urlEncode",
    signature: "urlEncode(string) -> String",
    description: "URL-encodes a string.",
    params: [{ name: "string", type: "String", description: "The string to encode" }],
    returns: { type: "String", description: "URL-encoded string" },
    examples: ['urlEncode("hello world")  -- "hello%20world"'],
  },
  urlDecode: {
    name: "urlDecode",
    signature: "urlDecode(string) -> String",
    description: "Decodes a URL-encoded string.",
    params: [{ name: "string", type: "String", description: "The URL-encoded string" }],
    returns: { type: "String", description: "Decoded string" },
    examples: ['urlDecode("hello%20world")  -- "hello world"'],
  },
  hexEncode: {
    name: "hexEncode",
    signature: "hexEncode(string) -> String",
    description: "Encodes a string to hexadecimal.",
    params: [{ name: "string", type: "String", description: "The string to encode" }],
    returns: { type: "String", description: "Hex-encoded string" },
    examples: ['hexEncode("AB")  -- "4142"'],
  },
  hexDecode: {
    name: "hexDecode",
    signature: "hexDecode(string) -> String",
    description: "Decodes a hexadecimal string.",
    params: [{ name: "string", type: "String", description: "The hex string" }],
    returns: { type: "String", description: "Decoded string" },
    examples: ['hexDecode("4142")  -- "AB"'],
  },

  // ===== Directory Operations =====
  mkdir: {
    name: "mkdir",
    signature: "mkdir(path, recursive?) -> Promise<Bool>",
    description: "Creates a directory. Recursive by default.",
    params: [
      { name: "path", type: "String", description: "Directory path" },
      { name: "recursive", type: "Bool", description: "Create parent dirs (default: true)" },
    ],
    returns: { type: "Promise<Bool>", description: "True on success" },
    examples: ['await mkdir("./new-dir")'],
  },
  rmdir: {
    name: "rmdir",
    signature: "rmdir(path, recursive?) -> Promise<Bool>",
    description: "Removes a directory. Non-recursive by default.",
    params: [
      { name: "path", type: "String", description: "Directory path" },
      { name: "recursive", type: "Bool", description: "Remove contents (default: false)" },
    ],
    returns: { type: "Promise<Bool>", description: "True on success" },
    examples: ['await rmdir("./old-dir", true)'],
  },
  copyFile: {
    name: "copyFile",
    signature: "copyFile(src, dest) -> Promise<Bool>",
    description: "Copies a file.",
    params: [
      { name: "src", type: "String", description: "Source path" },
      { name: "dest", type: "String", description: "Destination path" },
    ],
    returns: { type: "Promise<Bool>", description: "True on success" },
    examples: ['await copyFile("./a.txt", "./b.txt")'],
  },
  renameFile: {
    name: "renameFile",
    signature: "renameFile(oldPath, newPath) -> Promise<Bool>",
    description: "Renames or moves a file.",
    params: [
      { name: "oldPath", type: "String", description: "Current path" },
      { name: "newPath", type: "String", description: "New path" },
    ],
    returns: { type: "Promise<Bool>", description: "True on success" },
    examples: ['await renameFile("./old.txt", "./new.txt")'],
  },

  // ===== File Metadata =====
  fileStats: {
    name: "fileStats",
    signature: "fileStats(path) -> Promise<Record>",
    description: "Gets file metadata.",
    params: [{ name: "path", type: "String", description: "File path" }],
    returns: { type: "Promise<Record>", description: "{ size, isFile, isDirectory, isSymlink, createdAt, modifiedAt, accessedAt, mode }" },
    examples: ['let stats = await fileStats("./file.txt")'],
  },
  isFile: {
    name: "isFile",
    signature: "isFile(path) -> Promise<Bool>",
    description: "Checks if path is a file.",
    params: [{ name: "path", type: "String", description: "The path to check" }],
    returns: { type: "Promise<Bool>", description: "True if file" },
    examples: ['await isFile("./file.txt")  -- true'],
  },
  isDirectory: {
    name: "isDirectory",
    signature: "isDirectory(path) -> Promise<Bool>",
    description: "Checks if path is a directory.",
    params: [{ name: "path", type: "String", description: "The path to check" }],
    returns: { type: "Promise<Bool>", description: "True if directory" },
    examples: ['await isDirectory("./src")  -- true'],
  },

  // ===== Path Utilities =====
  pathJoin: {
    name: "pathJoin",
    signature: "pathJoin(...parts) -> String",
    description: "Joins path segments.",
    params: [{ name: "...parts", type: "String", description: "Path segments to join" }],
    returns: { type: "String", description: "Joined path" },
    examples: ['pathJoin("foo", "bar", "baz")  -- "foo/bar/baz"'],
  },
  pathDirname: {
    name: "pathDirname",
    signature: "pathDirname(path) -> String",
    description: "Gets the directory name of a path.",
    params: [{ name: "path", type: "String", description: "The path" }],
    returns: { type: "String", description: "Directory name" },
    examples: ['pathDirname("/foo/bar/baz.txt")  -- "/foo/bar"'],
  },
  pathBasename: {
    name: "pathBasename",
    signature: "pathBasename(path, ext?) -> String",
    description: "Gets the base name, optionally stripping an extension.",
    params: [
      { name: "path", type: "String", description: "The path" },
      { name: "ext", type: "String", description: "Extension to strip" },
    ],
    returns: { type: "String", description: "Base name" },
    examples: ['pathBasename("/foo/bar.txt")  -- "bar.txt"', 'pathBasename("/foo/bar.txt", ".txt")  -- "bar"'],
  },
  pathExtname: {
    name: "pathExtname",
    signature: "pathExtname(path) -> String",
    description: "Gets the extension of a path.",
    params: [{ name: "path", type: "String", description: "The path" }],
    returns: { type: "String", description: "Extension (including dot)" },
    examples: ['pathExtname("/foo/bar.txt")  -- ".txt"'],
  },
  pathResolve: {
    name: "pathResolve",
    signature: "pathResolve(...parts) -> String",
    description: "Resolves path segments to an absolute path.",
    params: [{ name: "...parts", type: "String", description: "Path segments" }],
    returns: { type: "String", description: "Absolute path" },
    examples: ['pathResolve("foo", "bar")  -- "/current/dir/foo/bar"'],
  },
  pathRelative: {
    name: "pathRelative",
    signature: "pathRelative(from, to) -> String",
    description: "Gets relative path from one path to another.",
    params: [
      { name: "from", type: "String", description: "Starting path" },
      { name: "to", type: "String", description: "Target path" },
    ],
    returns: { type: "String", description: "Relative path" },
    examples: ['pathRelative("/foo/bar", "/foo/baz")  -- "../baz"'],
  },
  pathNormalize: {
    name: "pathNormalize",
    signature: "pathNormalize(path) -> String",
    description: "Normalizes a path (resolves . and ..).",
    params: [{ name: "path", type: "String", description: "The path" }],
    returns: { type: "String", description: "Normalized path" },
    examples: ['pathNormalize("/foo/bar/../baz")  -- "/foo/baz"'],
  },
  pathIsAbsolute: {
    name: "pathIsAbsolute",
    signature: "pathIsAbsolute(path) -> Bool",
    description: "Checks if path is absolute.",
    params: [{ name: "path", type: "String", description: "The path" }],
    returns: { type: "Bool", description: "True if absolute" },
    examples: ['pathIsAbsolute("/foo")  -- true', 'pathIsAbsolute("foo")  -- false'],
  },
  pathParse: {
    name: "pathParse",
    signature: "pathParse(path) -> Record",
    description: "Parses a path into components.",
    params: [{ name: "path", type: "String", description: "The path" }],
    returns: { type: "Record", description: "{ root, dir, base, ext, name }" },
    examples: ['pathParse("/foo/bar.txt")  -- { root: "/", dir: "/foo", base: "bar.txt", ext: ".txt", name: "bar" }'],
  },

  // ===== Environment =====
  getEnv: {
    name: "getEnv",
    signature: "getEnv(name) -> String | null",
    description: "Gets an environment variable.",
    params: [{ name: "name", type: "String", description: "Variable name" }],
    returns: { type: "String | null", description: "Value or null" },
    examples: ['getEnv("HOME")  -- "/home/user"'],
  },
  getEnvAll: {
    name: "getEnvAll",
    signature: "getEnvAll() -> Record",
    description: "Gets all environment variables.",
    params: [],
    returns: { type: "Record", description: "All env vars as record" },
    examples: ["getEnvAll()  -- { HOME: \"/home/user\", ... }"],
  },
  cwd: {
    name: "cwd",
    signature: "cwd() -> String",
    description: "Gets the current working directory.",
    params: [],
    returns: { type: "String", description: "Current directory path" },
    examples: ['cwd()  -- "/home/user/project"'],
  },
  homeDir: {
    name: "homeDir",
    signature: "homeDir() -> String",
    description: "Gets the user's home directory.",
    params: [],
    returns: { type: "String", description: "Home directory path" },
    examples: ['homeDir()  -- "/home/user"'],
  },
  tmpDir: {
    name: "tmpDir",
    signature: "tmpDir() -> String",
    description: "Gets the temp directory.",
    params: [],
    returns: { type: "String", description: "Temp directory path" },
    examples: ['tmpDir()  -- "/tmp"'],
  },
  platform: {
    name: "platform",
    signature: "platform() -> String",
    description: "Gets the operating system platform.",
    params: [],
    returns: { type: "String", description: "Platform name (linux, darwin, win32)" },
    examples: ['platform()  -- "linux"'],
  },
};

/**
 * Get all builtin function names
 */
export function getBuiltinNames(): string[] {
  return Object.keys(BUILTIN_DOCS);
}

/**
 * Get documentation for a builtin function
 */
export function getBuiltinDoc(name: string): BuiltinDoc | undefined {
  return BUILTIN_DOCS[name];
}

/**
 * Check if a name is a builtin function
 */
export function isBuiltin(name: string): boolean {
  return name in BUILTIN_DOCS || name === "__identity__";
}
