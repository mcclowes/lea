-- Test reactive pipelines

-- Basic reactive pipeline with maybe source
maybe source = [1, 2, 3]
let double = (x) -> x * 2
let r = source @> map(double) /> reduce(0, (a, b) -> a + b)
r.value /> print  -- 12 (2 + 4 + 6)

-- Mutation triggers recomputation
source = [1, 2, 3, 4]
r.value /> print  -- 20 (2 + 4 + 6 + 8)

-- Lazy evaluation - same value returns cached
source = [10, 20]
r.value /> print  -- 60 (20 + 40)
r.value /> print  -- 60 (cached)

-- Auto-unwrap in binary operations
maybe nums = [1, 2, 3, 4, 5]
let sum = nums @> reduce(0, (a, b) -> a + b)
(sum + 100) /> print  -- 115 (15 + 100)
(sum * 2) /> print    -- 30 (15 * 2)
(sum == 15) /> print  -- true

-- Static source optimization (primitives)
-- Primitive sources return direct value, not reactive
let x = 5
let static_result = x @> (n) -> n * 2
static_result /> print   -- 10 (direct value, not reactive)

-- Array source with let (mutable by reference)
let arr = [1, 2]
let arr_reactive = arr @> reduce(0, (a, b) -> a + b)
print(arr_reactive)      -- <reactive[arr]>
arr_reactive.value /> print  -- 3

-- Multi-stage pipeline
maybe data = [1, 2, 3, 4, 5, 6]
let processed = data @> filter((x) -> x > 2) /> map((x) -> x * 10) /> reduce(0, (a, b) -> a + b)
processed.value /> print  -- 180 (30 + 40 + 50 + 60)

data = [10, 20, 30]
processed.value /> print  -- 600 (100 + 200 + 300)

-- String concatenation with reactive (using record wrapper)
maybe config = { prefix: "Hello" }
let greeting = config @> (c) -> c.prefix ++ " World"
greeting.value /> print  -- "Hello World"
config = { prefix: "Hi" }
greeting.value /> print  -- "Hi World"

"All reactive tests passed!" /> print
