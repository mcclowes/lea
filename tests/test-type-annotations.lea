-- Test: New trailing type annotation syntax :: (Type) :> ReturnType

-- Single parameter, single-line function
let square = (x) -> x * x :: Int :> Int #validate
square(5) /> print  -- 25

-- Multiple parameters with type signature
let add = (a, b) -> a + b :: (Int, Int) :> Int #validate
add(3, 4) /> print  -- 7

-- Multiline function with type annotation after arrow
let multiply = (a, b) -> :: (Int, Int) :> Int
  let result = a * b
  result
  #validate

multiply(6, 7) /> print  -- 42

-- String types
let greet = (name) -> "Hello, " ++ name :: String :> String #validate
greet("Lea") /> print  -- Hello, Lea

-- Mixed types
let repeatStr = (s, n) -> :: (String, Int) :> String
  iterations(n) /> reduce("", (acc, _) -> acc ++ s)
  #validate

repeatStr("hi", 3) /> print  -- hihihi

-- Type validation should catch wrong types
let typed = (x) -> x + 1 :: Int :> Int #validate

-- This should work
typed(10) /> print  -- 11

-- Without #validate, types are just documentation
let documented = (x) -> x ++ x :: String :> String
documented("hello") /> print  -- hello hello - types are just docs without validate

-- List types: [Int], [String], etc.
let sumList = (nums) -> reduce(nums, 0, (acc, x) -> acc + x) :: [Int] :> Int #validate
sumList([1, 2, 3, 4, 5]) /> print  -- 15

let joinStrings = (strs) -> reduce(strs, "", (acc, s) -> acc ++ s) :: [String] :> String #validate
joinStrings(["hello", " ", "world"]) /> print  -- hello world

-- List type as return type
let getRange = (n) -> range(n) :: Int :> [Int] #validate
getRange(5) /> print  -- [0, 1, 2, 3, 4]

-- List of lists
let flatten = (lists) -> reduce(lists, [], (acc, list) -> concat(acc, list)) :: [[Int]] :> [Int]
flatten([[1, 2], [3, 4]]) /> print  -- [1, 2, 3, 4] - note: nested list types work as documentation

print("All type annotation tests passed!")
