{
  "Let Binding": {
    "prefix": "let",
    "body": ["let ${1:name} = ${2:value}"],
    "description": "Create an immutable binding"
  },
  "Maybe Binding": {
    "prefix": "maybe",
    "body": ["maybe ${1:name} = ${2:value}"],
    "description": "Create a mutable binding"
  },
  "Function": {
    "prefix": "fn",
    "body": ["let ${1:name} = (${2:params}) -> ${3:body}"],
    "description": "Create a function"
  },
  "Function with Type": {
    "prefix": "fnt",
    "body": ["let ${1:name} = (${2:params}) -> ${3:body} :: ${4:ParamTypes} :> ${5:ReturnType}"],
    "description": "Create a typed function"
  },
  "Multi-line Function": {
    "prefix": "fnm",
    "body": [
      "let ${1:name} = (${2:params}) ->",
      "  ${3:body}"
    ],
    "description": "Create a multi-line function"
  },
  "Arrow Function": {
    "prefix": "->",
    "body": ["(${1:x}) -> ${2:body}"],
    "description": "Anonymous arrow function"
  },
  "Pipe": {
    "prefix": "/>",
    "body": ["/> ${1:function}"],
    "description": "Pipe operator"
  },
  "Pipe Chain": {
    "prefix": "pipec",
    "body": [
      "${1:value}",
      "  /> ${2:fn1}",
      "  /> ${3:fn2}",
      "  /> ${4:fn3}"
    ],
    "description": "Chained pipe operations"
  },
  "Map": {
    "prefix": "map",
    "body": ["/> map((${1:x}) -> ${2:body})"],
    "description": "Map over a list"
  },
  "Filter": {
    "prefix": "filter",
    "body": ["/> filter((${1:x}) -> ${2:condition})"],
    "description": "Filter a list"
  },
  "Reduce": {
    "prefix": "reduce",
    "body": ["/> reduce(${1:initial}, (${2:acc}, ${3:x}) -> ${4:body})"],
    "description": "Reduce a list"
  },
  "Map Filter Reduce": {
    "prefix": "mfr",
    "body": [
      "${1:list}",
      "  /> filter((x) -> ${2:condition})",
      "  /> map((x) -> ${3:transform})",
      "  /> reduce(${4:0}, (acc, x) -> ${5:acc + x})"
    ],
    "description": "Complete map-filter-reduce pipeline"
  },
  "Record": {
    "prefix": "rec",
    "body": [
      "{",
      "  ${1:key}: ${2:value},",
      "}"
    ],
    "description": "Create a record"
  },
  "Record Destructure": {
    "prefix": "desr",
    "body": ["let { ${1:key} } = ${2:record}"],
    "description": "Destructure a record"
  },
  "Tuple Destructure": {
    "prefix": "dest",
    "body": ["let (${1:a}, ${2:b}) = ${3:tuple}"],
    "description": "Destructure a tuple"
  },
  "Pattern Match": {
    "prefix": "match",
    "body": [
      "match ${1:value}",
      "  | ${2:pattern} -> ${3:result}",
      "  | ${4:default}"
    ],
    "description": "Pattern matching expression"
  },
  "Match with Guards": {
    "prefix": "matchg",
    "body": [
      "match ${1:value}",
      "  | if input ${2:< 0} -> ${3:\"negative\"}",
      "  | if input ${4:> 0} -> ${5:\"positive\"}",
      "  | ${6:\"zero\"}"
    ],
    "description": "Pattern matching with guards"
  },
  "Context Definition": {
    "prefix": "context",
    "body": ["context ${1:Name} = { ${2:key}: ${3:value} }"],
    "description": "Define a context"
  },
  "Provide Context": {
    "prefix": "provide",
    "body": ["provide ${1:ContextName} { ${2:key}: ${3:value} }"],
    "description": "Provide a context value"
  },
  "Async Function": {
    "prefix": "async",
    "body": ["let ${1:name} = (${2:params}) -> ${3:body} #async"],
    "description": "Create an async function"
  },
  "Await": {
    "prefix": "await",
    "body": ["await ${1:expression}"],
    "description": "Await an async expression"
  },
  "Parallel": {
    "prefix": "parallel",
    "body": ["${1:list} /> parallel((${2:x}) -> ${3:asyncOp})"],
    "description": "Parallel map over list"
  },
  "Pipeline Definition": {
    "prefix": "pipeline",
    "body": ["let ${1:name} = /> ${2:fn1} /> ${3:fn2}"],
    "description": "Define a first-class pipeline"
  },
  "Bidirectional Pipeline": {
    "prefix": "bipipe",
    "body": ["let ${1:name} = </> ${2:fn1} </> ${3:fn2}"],
    "description": "Define a bidirectional pipeline"
  },
  "Reversible Function": {
    "prefix": "rev",
    "body": [
      "let ${1:name} = (${2:x}) -> ${3:forwardBody}",
      "and ${1:name} = (${2:x}) <- ${4:reverseBody}"
    ],
    "description": "Create a reversible function"
  },
  "Function Overload": {
    "prefix": "overload",
    "body": [
      "let ${1:name} = (${2:a}, ${3:b}) -> ${4:body1} :: (${5:Type1}, ${6:Type2}) :> ${7:ReturnType1}",
      "and ${1:name} = (${2:a}, ${3:b}) -> ${8:body2} :: (${9:Type3}, ${10:Type4}) :> ${11:ReturnType2}"
    ],
    "description": "Create overloaded functions"
  },
  "Decorator Log": {
    "prefix": "#log",
    "body": ["#log"],
    "description": "Add logging decorator"
  },
  "Decorator Memo": {
    "prefix": "#memo",
    "body": ["#memo"],
    "description": "Add memoization decorator"
  },
  "Decorator Time": {
    "prefix": "#time",
    "body": ["#time"],
    "description": "Add timing decorator"
  },
  "Decorator Retry": {
    "prefix": "#retry",
    "body": ["#retry(${1:3})"],
    "description": "Add retry decorator"
  },
  "Decorator Validate": {
    "prefix": "#validate",
    "body": ["#validate"],
    "description": "Add validation decorator"
  },
  "Reactive Pipeline": {
    "prefix": "reactive",
    "body": ["let ${1:name} = ${2:source} @> ${3:transform}"],
    "description": "Create a reactive pipeline"
  },
  "Fetch": {
    "prefix": "fetch",
    "body": ["await fetch(\"${1:url}\")"],
    "description": "HTTP fetch request"
  },
  "Fetch POST": {
    "prefix": "fetchp",
    "body": [
      "await fetch(\"${1:url}\", {",
      "  method: \"POST\",",
      "  headers: { \"Content-Type\": \"application/json\" },",
      "  body: ${2:data}",
      "})"
    ],
    "description": "HTTP POST request"
  },
  "Read File": {
    "prefix": "readf",
    "body": ["await readFile(\"${1:path}\")"],
    "description": "Read file contents"
  },
  "Write File": {
    "prefix": "writef",
    "body": ["await writeFile(\"${1:path}\", ${2:content})"],
    "description": "Write to file"
  },
  "Codeblock": {
    "prefix": "codeblock",
    "body": [
      "{-- ${1:Section Name} --}",
      "${2:code}",
      "{/--}"
    ],
    "description": "Create a collapsible codeblock"
  },
  "Print": {
    "prefix": "print",
    "body": ["${1:value} /> print"],
    "description": "Print a value"
  },
  "Range": {
    "prefix": "range",
    "body": ["range(${1:1}, ${2:10})"],
    "description": "Create a range of numbers"
  },
  "Ternary": {
    "prefix": "tern",
    "body": ["${1:condition} ? ${2:ifTrue} : ${3:ifFalse}"],
    "description": "Ternary conditional"
  },
  "Spread List": {
    "prefix": "spread",
    "body": ["[...${1:list1}, ...${2:list2}]"],
    "description": "Spread and combine lists"
  },
  "Spread Record": {
    "prefix": "spreadr",
    "body": ["{ ...${1:record}, ${2:key}: ${3:value} }"],
    "description": "Spread and extend record"
  },
  "Parallel Pipe": {
    "prefix": "\\>",
    "body": ["\\> ${1:fn}"],
    "description": "Parallel pipe branch"
  },
  "Spread Pipe": {
    "prefix": "/>>>",
    "body": ["/>>>${1:fn}"],
    "description": "Spread pipe operator"
  },
  "Template String": {
    "prefix": "tpl",
    "body": ["`${1:text} {${2:expr}}`"],
    "description": "Template string with interpolation"
  },
  "FizzBuzz Example": {
    "prefix": "fizzbuzz",
    "body": [
      "let fizzbuzz = (n) -> match n",
      "  | if input % 15 == 0 -> \"FizzBuzz\"",
      "  | if input % 3 == 0 -> \"Fizz\"",
      "  | if input % 5 == 0 -> \"Buzz\"",
      "  | toString(input)",
      "",
      "range(1, 101) /> map(fizzbuzz) /> print"
    ],
    "description": "FizzBuzz implementation"
  }
}
